#!/usr/bin/env python3
"""
sorting_test.py

RSA Project 2
Larry Davis, London Slott, Ryan McKinney
Due 9/28/25

"""

import random
import time

# -------------------------
# Sorting algorithms
# -------------------------

def bubbleSort_(myList):  # Bubble Sort Algorithm
    done = False
    for i in range(len(myList) - 1):
        swap = False
        if not done:
            for j in range(len(myList) - i - 1):
                if myList[j] > myList[j + 1]:
                    myList[j], myList[j + 1] = myList[j + 1], myList[j]
                    swap = True
            if not swap:
                done = True
                break
    return myList

def mergeSort_(myList):  # Merge Sort Algorithm
    if len(myList) > 1:
        mid = len(myList) // 2
        left = myList[:mid]
        right = myList[mid:]

        mergeSort_(left)
        mergeSort_(right)

        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                myList[k] = left[i]
                i += 1
            else:
                myList[k] = right[j]
                j += 1
            k += 1

        while i < len(left):
            myList[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            myList[k] = right[j]
            j += 1
            k += 1
    return myList

def quickSort_(arr):  # Quick Sort Algorithm
    if len(arr) <= 1:
        return arr
    else:
        pivot = random.choice(arr)
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quickSort_(left) + middle + quickSort_(right)

def insertionSort_(myList):  # Insertion Sort Algorithm
    for i in range(1, len(myList)):
        key = myList[i]
        j = i - 1
        while j >= 0 and myList[j] > key:
            myList[j + 1] = myList[j]
            j -= 1
        myList[j + 1] = key
    return myList

# -------------------------
# Input generators
# -------------------------

def generate_sorted(n):
    return list(range(n))

def generate_reverse(n):
    return list(range(n, 0, -1))

def generate_random(n):
    return random.sample(range(10 * n), n)

# -------------------------
# Timing function
# -------------------------

def time_sort(func, arr):
    start = time.perf_counter()
    func(arr[:])  # pass a copy so input isnâ€™t destroyed
    end = time.perf_counter()
    return end - start

# -------------------------
# Experiment runner
# -------------------------

def run_case(algorithm, case_type):
    algos = {
        "bubble": bubbleSort_,
        "merge": mergeSort_,
        "quick": quickSort_,
        "insertion": insertionSort_
    }
    func = algos[algorithm]

    if case_type == "best":
        gen_func = generate_sorted
    elif case_type == "average":
        gen_func = generate_random
    elif case_type == "worst":
        gen_func = generate_reverse
    else:
        return

    print(f"In {case_type} case,")

    # Default test sizes
    for n in [100, 1000, 10000]:
        arr = gen_func(n)
        elapsed = time_sort(func, arr)
        print(f"For N = {n}, it takes {elapsed:.6f} seconds")

    # Ask user if they want to continue
    while True:
        cont = input("Do you want to input another N (Y/N)? ").strip().lower()
        if cont == "y":
            try:
                n = int(input("What is the N? ").strip())
                arr = gen_func(n)
                elapsed = time_sort(func, arr)
                print(f"For N = {n}, it takes {elapsed:.6f} seconds")
            except ValueError:
                print("Invalid input. Try again.")
        else:
            break

# -------------------------
# Interactive menu
# -------------------------

def interactive_menu():
    print("Welcome to the test suite of selected sorting algorithms!")
    while True:
        print("Select the sorting algorithm you want to test.")
        print("-------------------------")
        print("1. Bubble Sort")
        print("2. Merge Sort")
        print("3. Quick Sort")
        print("4. Insertion Sort")
        print("5. Exit")
        choice = input("Select a sorting algorithm (1-5): ").strip()

        mapping = {"1": "bubble", "2": "merge", "3": "quick", "4": "insertion", "5": "exit"}
        if choice not in mapping:
            print("Invalid choice.")
            continue
        if mapping[choice] == "exit":
            print("Bye!")
            break

        alg = mapping[choice]
        while True:
            print(f"Case Scenarios for {alg.capitalize()} Sort")
            print("---------------")
            print("1. Best Case")
            print("2. Average Case")
            print("3. Worst Case")
            print(f"4. Exit {alg} sort test")
            c = input("Select the case (1-4): ").strip()
            cmapping = {"1": "best", "2": "average", "3": "worst", "4": "back"}

            if c not in cmapping:
                print("Invalid choice.")
                continue
            if cmapping[c] == "back":
                break

            run_case(alg, cmapping[c])

# -------------------------
# Main
# -------------------------

def main():
    interactive_menu()

if __name__ == "__main__":
    main()
